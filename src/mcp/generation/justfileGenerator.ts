import type { MonorepoConfig } from '../config/monorepoConfigLoader.js';
import type { DetectedSubmodule } from '../detection/projectDetector.js';

/**
 * Options for justfile generation
 */
export interface JustfileGeneratorOptions {
  /** Include comments in generated file */
  includeComments?: boolean;
  /** Script directory (relative to project root) */
  scriptDir?: string;
  /** Cache directory (from config) */
  cacheDir?: string;
}

const defaultOptions: Required<JustfileGeneratorOptions> = {
  includeComments: true,
  scriptDir: 'scripts',
  cacheDir: '.repomix-cache',
};

/**
 * Generates justfile content for monorepo cache management
 */
export class JustfileGenerator {
  private submodules: DetectedSubmodule[];
  private options: Required<JustfileGeneratorOptions>;

  constructor(config: MonorepoConfig, submodules: DetectedSubmodule[], options: JustfileGeneratorOptions = {}) {
    this.submodules = submodules;
    this.options = { ...defaultOptions, ...options };
    if (config.cache?.directory) {
      this.options.cacheDir = config.cache.directory;
    }
  }

  /**
   * Generate the complete justfile content
   */
  generate(): string {
    const lines: string[] = [];

    // Header
    if (this.options.includeComments) {
      lines.push('# Repomix Monorepo Cache Management');
      lines.push('# Auto-generated by repomix init_monorepo_config');
      lines.push('# Do not edit manually - regenerate with the init_monorepo_config tool');
      lines.push('');
    }

    // Variables
    lines.push(`cache_dir := "${this.options.cacheDir}"`);
    lines.push(`script_dir := "${this.options.scriptDir}"`);
    lines.push('');

    // Default recipe (list all recipes)
    lines.push('# List all available recipes');
    lines.push('default:');
    lines.push('    @just --list');
    lines.push('');

    // Global cache operations
    lines.push(...this.generateGlobalRecipes());

    // Per-submodule recipes
    lines.push(...this.generateSubmoduleRecipes());

    // Utility recipes
    lines.push(...this.generateUtilityRecipes());

    return lines.join('\n');
  }

  /**
   * Generate global cache management recipes
   */
  private generateGlobalRecipes(): string[] {
    const lines: string[] = [];

    if (this.options.includeComments) {
      lines.push('# ═══════════════════════════════════════════════════════════');
      lines.push('# Global Cache Operations');
      lines.push('# ═══════════════════════════════════════════════════════════');
      lines.push('');
    }

    // Update all caches
    lines.push('# Regenerate cache for all submodules');
    lines.push('update-all-caches:');
    lines.push('    node {{script_dir}}/repomix-cache.mjs --all --regenerate');
    lines.push('');

    // Invalidate all caches
    lines.push('# Invalidate all cached content (force regeneration on next access)');
    lines.push('invalidate-all-caches:');
    lines.push('    node {{script_dir}}/repomix-cache.mjs --all --invalidate');
    lines.push('');

    // Update only changed caches
    lines.push('# Update only submodules that have changed since last cache');
    lines.push('update-changed-caches:');
    lines.push('    node {{script_dir}}/repomix-cache.mjs --changed-only');
    lines.push('');

    // Show cache status
    lines.push('# Show cache status for all submodules');
    lines.push('cache-status:');
    lines.push('    node {{script_dir}}/repomix-cache.mjs --status');
    lines.push('');

    // Clean cache directory
    lines.push('# Remove all cached files');
    lines.push('clean-cache:');
    lines.push('    rm -rf {{cache_dir}}');
    lines.push('    @echo "Cache directory cleaned"');
    lines.push('');

    return lines;
  }

  /**
   * Generate per-submodule recipes
   */
  private generateSubmoduleRecipes(): string[] {
    const lines: string[] = [];

    if (this.submodules.length === 0) {
      return lines;
    }

    if (this.options.includeComments) {
      lines.push('# ═══════════════════════════════════════════════════════════');
      lines.push('# Individual Submodule Operations');
      lines.push('# ═══════════════════════════════════════════════════════════');
      lines.push('');
    }

    for (const submodule of this.submodules) {
      const safeName = this.sanitizeName(submodule.name);
      const description = submodule.description || `${submodule.type} package at ${submodule.path}`;

      // Update recipe
      lines.push(`# Update cache for ${submodule.name} (${description})`);
      lines.push(`update-${safeName}:`);
      lines.push(`    node {{script_dir}}/repomix-cache.mjs --module=${submodule.name} --regenerate`);
      lines.push('');

      // Invalidate recipe
      lines.push(`# Invalidate cache for ${submodule.name}`);
      lines.push(`invalidate-${safeName}:`);
      lines.push(`    node {{script_dir}}/repomix-cache.mjs --module=${submodule.name} --invalidate`);
      lines.push('');
    }

    // Generic update/invalidate with parameter
    lines.push('# Update cache for a specific module by name');
    lines.push('update-module module:');
    lines.push('    node {{script_dir}}/repomix-cache.mjs --module={{module}} --regenerate');
    lines.push('');

    lines.push('# Invalidate cache for a specific module by name');
    lines.push('invalidate-module module:');
    lines.push('    node {{script_dir}}/repomix-cache.mjs --module={{module}} --invalidate');
    lines.push('');

    return lines;
  }

  /**
   * Generate utility recipes
   */
  private generateUtilityRecipes(): string[] {
    const lines: string[] = [];

    if (this.options.includeComments) {
      lines.push('# ═══════════════════════════════════════════════════════════');
      lines.push('# Utility Recipes');
      lines.push('# ═══════════════════════════════════════════════════════════');
      lines.push('');
    }

    // List submodules
    lines.push('# List all configured submodules');
    lines.push('list-submodules:');
    lines.push('    node {{script_dir}}/repomix-cache.mjs --list');
    lines.push('');

    // Show dependencies
    lines.push('# Show dependency graph');
    lines.push('show-dependencies:');
    lines.push('    node {{script_dir}}/repomix-cache.mjs --dependencies');
    lines.push('');

    // Initialize/reinitialize config
    lines.push('# Regenerate monorepo configuration (auto-detect submodules)');
    lines.push('init-config:');
    lines.push('    @echo "Use the init_monorepo_config MCP tool to regenerate configuration"');
    lines.push('');

    // Install git hooks
    lines.push('# Install git post-commit hook for automatic cache invalidation');
    lines.push('install-hooks:');
    lines.push('    #!/usr/bin/env bash');
    lines.push('    mkdir -p .git/hooks');
    lines.push("    cat > .git/hooks/post-commit << 'HOOK'");
    lines.push('    #!/bin/bash');
    lines.push('    # Repomix cache invalidation hook');
    lines.push('    (node {{script_dir}}/repomix-cache.mjs --changed-only &) 2>/dev/null');
    lines.push('    HOOK');
    lines.push('    chmod +x .git/hooks/post-commit');
    lines.push('    @echo "Git hook installed"');
    lines.push('');

    return lines;
  }

  /**
   * Sanitize a name for use in just recipes
   * Converts to lowercase, replaces non-alphanumeric with dashes
   */
  private sanitizeName(name: string): string {
    return name
      .toLowerCase()
      .replace(/[^a-z0-9]/g, '-')
      .replace(/-+/g, '-')
      .replace(/^-|-$/g, '');
  }
}

/**
 * Generate the cache management script content
 */
export function generateCacheScript(): string {
  return `#!/usr/bin/env node
/**
 * Repomix Monorepo Cache Management Script
 * Auto-generated by repomix init_monorepo_config
 */

import fs from 'node:fs/promises';
import path from 'node:path';
import { parseArgs } from 'node:util';

const CONFIG_FILE = '.repomix-monorepo.json';

async function main() {
  const { values } = parseArgs({
    options: {
      all: { type: 'boolean', default: false },
      module: { type: 'string' },
      'changed-only': { type: 'boolean', default: false },
      regenerate: { type: 'boolean', default: false },
      invalidate: { type: 'boolean', default: false },
      status: { type: 'boolean', default: false },
      list: { type: 'boolean', default: false },
      dependencies: { type: 'boolean', default: false },
    },
  });

  // Load config
  let config;
  try {
    const content = await fs.readFile(CONFIG_FILE, 'utf-8');
    config = JSON.parse(content);
  } catch (error) {
    console.error('Error: Could not load', CONFIG_FILE);
    console.error('Run the init_monorepo_config MCP tool first.');
    process.exit(1);
  }

  const cacheDir = config.cache?.directory || '.repomix-cache';

  if (values.list) {
    console.log('Configured submodules:');
    for (const [name, sub] of Object.entries(config.submodules)) {
      const submodule = sub;
      console.log(\`  - \${name}: \${submodule.path}\${submodule.isGitSubmodule ? ' (git submodule)' : ''}\`);
    }
    return;
  }

  if (values.dependencies) {
    console.log('Dependency graph:');
    for (const [name, sub] of Object.entries(config.submodules)) {
      const submodule = sub;
      const deps = submodule.dependencies || [];
      console.log(\`  \${name}: \${deps.length > 0 ? deps.join(', ') : '(no dependencies)'}\`);
    }
    return;
  }

  if (values.status) {
    console.log('Cache status:');
    console.log('');
    console.log('Submodule'.padEnd(30), 'Status'.padEnd(15), 'Last Updated');
    console.log('-'.repeat(70));

    for (const [name] of Object.entries(config.submodules)) {
      const metaPath = path.join(cacheDir, \`\${name}.meta.json\`);
      try {
        const metaContent = await fs.readFile(metaPath, 'utf-8');
        const meta = JSON.parse(metaContent);
        const lastUpdated = new Date(meta.generatedAt).toLocaleString();
        console.log(name.padEnd(30), 'Cached'.padEnd(15), lastUpdated);
      } catch {
        console.log(name.padEnd(30), 'Not cached'.padEnd(15), '-');
      }
    }
    return;
  }

  // Determine which submodules to process
  let submodulesToProcess = [];
  if (values.module) {
    if (!config.submodules[values.module]) {
      console.error(\`Error: Submodule "\${values.module}" not found in configuration\`);
      process.exit(1);
    }
    submodulesToProcess = [values.module];
  } else if (values.all || values['changed-only']) {
    submodulesToProcess = Object.keys(config.submodules);
  } else {
    console.error('Error: Specify --all, --changed-only, or --module=<name>');
    process.exit(1);
  }

  // Process submodules
  for (const name of submodulesToProcess) {
    if (values.invalidate) {
      const metaPath = path.join(cacheDir, \`\${name}.meta.json\`);
      const contentPath = path.join(cacheDir, \`\${name}.xml\`);
      await fs.rm(metaPath, { force: true });
      await fs.rm(contentPath, { force: true });
      console.log(\`Invalidated: \${name}\`);
    } else if (values.regenerate) {
      console.log(\`Regenerating: \${name} (use MCP tool for actual regeneration)\`);
      // Note: Actual regeneration happens through MCP tool
      // This script just manages cache files
    }
  }
}

main().catch(console.error);
`;
}
