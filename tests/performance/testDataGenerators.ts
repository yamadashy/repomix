import type { SupportedLang } from '../../src/core/treeSitter/lang2Query.js';

/**
 * Performance test data generators for creating large files with realistic code structure
 */

export interface PerformanceTestCase {
  language: SupportedLang;
  lineCount: number;
  lineLimit: number;
  expectedMaxTimeMs: number;
  expectedMaxMemoryMB: number;
}

export interface GeneratedFile {
  content: string;
  filePath: string;
  language: SupportedLang;
  actualLineCount: number;
}

/**
 * Generate large JavaScript files with realistic structure
 */
export function generateLargeJavaScriptFile(lineCount: number): string {
  const imports = [
    "import React from 'react';",
    "import { useState, useEffect, useCallback } from 'react';",
    "import PropTypes from 'prop-types';",
    "import axios from 'axios';",
    "import { debounce, throttle } from 'lodash';",
    "import { format, parseISO } from 'date-fns';",
  ];

  const interfaces = [
    'interface User {',
    '  id: number;',
    '  name: string;',
    '  email: string;',
    '  avatar?: string;',
    '  createdAt: Date;',
    '  updatedAt?: Date;',
    '  roles: UserRole[];',
    '}',
    '',
    'interface UserRole {',
    '  id: number;',
    '  name: string;',
    '  permissions: string[];',
    '}',
    '',
    'interface ApiResponse<T> {',
    '  data: T;',
    '  success: boolean;',
    '  message?: string;',
    '  pagination?: {',
    '    page: number;',
    '    limit: number;',
    '    total: number;',
    '  };',
    '}',
  ];

  const utilityFunctions = [
    'const formatDate = (date: Date | string): string => {',
    "  const d = typeof date === 'string' ? parseISO(date) : date;",
    "  return format(d, 'yyyy-MM-dd HH:mm:ss');",
    '};',
    '',
    'const validateEmail = (email: string): boolean => {',
    '  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;',
    '  return emailRegex.test(email);',
    '};',
    '',
    'const generateId = (): string => {',
    '  return Math.random().toString(36).substr(2, 9);',
    '};',
    '',
    'const debounceAsync = <T extends any[], R>(',
    '  func: (...args: T) => Promise<R>,',
    '  delay: number',
    ') => {',
    '  let timeoutId: NodeJS.Timeout;',
    '  return (...args: T): Promise<R> => {',
    '    return new Promise((resolve, reject) => {',
    '      clearTimeout(timeoutId);',
    '      timeoutId = setTimeout(async () => {',
    '        try {',
    '          const result = await func(...args);',
    '          resolve(result);',
    '        } catch (error) {',
    '          reject(error);',
    '        }',
    '      }, delay);',
    '    });',
    '  };',
    '};',
  ];

  const complexClass = [
    'class UserService {',
    '  private baseUrl: string;',
    '  private cache: Map<string, any> = new Map();',
    '  private retryCount: number = 3;',
    '',
    '  constructor(baseUrl: string) {',
    '    this.baseUrl = baseUrl;',
    '  }',
    '',
    '  async getUsers(params: {',
    '    page?: number;',
    '    limit?: number;',
    '    search?: string;',
    '    role?: string;',
    '  } = {}): Promise<ApiResponse<User[]>> {',
    '    const cacheKey = `users_${JSON.stringify(params)}`;',
    '    ',
    '    if (this.cache.has(cacheKey)) {',
    '      return this.cache.get(cacheKey);',
    '    }',
    '',
    '    try {',
    '      const response = await axios.get(`${this.baseUrl}/users`, { params });',
    '      const data = response.data;',
    '      ',
    '      this.cache.set(cacheKey, data);',
    '      return data;',
    '    } catch (error) {',
    "      console.error('Error fetching users:', error);",
    '      throw error;',
    '    }',
    '  }',
    '',
    '  async createUser(userData: Partial<User>): Promise<User> {',
    '    try {',
    '      const response = await axios.post(`${this.baseUrl}/users`, userData);',
    '      this.cache.clear(); // Clear cache after mutation',
    '      return response.data;',
    '    } catch (error) {',
    "      console.error('Error creating user:', error);",
    '      throw error;',
    '    }',
    '  }',
    '',
    '  async updateUser(id: number, userData: Partial<User>): Promise<User> {',
    '    try {',
    '      const response = await axios.put(`${this.baseUrl}/users/${id}`, userData);',
    '      this.cache.clear(); // Clear cache after mutation',
    '      return response.data;',
    '    } catch (error) {',
    "      console.error('Error updating user:', error);",
    '      throw error;',
    '    }',
    '  }',
    '',
    '  async deleteUser(id: number): Promise<void> {',
    '    try {',
    '      await axios.delete(`${this.baseUrl}/users/${id}`);',
    '      this.cache.clear(); // Clear cache after mutation',
    '    } catch (error) {',
    "      console.error('Error deleting user:', error);",
    '      throw error;',
    '    }',
    '  }',
    '',
    '  private async retryOperation<T>(',
    '    operation: () => Promise<T>,',
    '    retries: number = this.retryCount',
    '  ): Promise<T> {',
    '    try {',
    '      return await operation();',
    '    } catch (error) {',
    '      if (retries <= 0) {',
    '        throw error;',
    '      }',
    '      await new Promise(resolve => setTimeout(resolve, 1000));',
    '      return this.retryOperation(operation, retries - 1);',
    '    }',
    '  }',
    '}',
  ];

  const reactComponent = [
    'const UserList: React.FC<{',
    '  service: UserService;',
    '  onUserSelect?: (user: User) => void;',
    '>} = ({ service, onUserSelect }) => {',
    '  const [users, setUsers] = useState<User[]>([]);',
    '  const [loading, setLoading] = useState(false);',
    '  const [error, setError] = useState<string | null>(null);',
    "  const [searchTerm, setSearchTerm] = useState('');",
    '  const [page, setPage] = useState(1);',
    '',
    '  const loadUsers = useCallback(async () => {',
    '    setLoading(true);',
    '    setError(null);',
    '    ',
    '    try {',
    '      const response = await service.getUsers({',
    '        page,',
    '        limit: 20,',
    '        search: searchTerm || undefined,',
    '      });',
    '      ',
    '      if (response.success) {',
    '        setUsers(response.data);',
    '      } else {',
    "        setError(response.message || 'Failed to load users');",
    '      }',
    '    } catch (err) {',
    "      setError(err instanceof Error ? err.message : 'Unknown error');",
    '    } finally {',
    '      setLoading(false);',
    '    }',
    '  }, [service, page, searchTerm]);',
    '',
    '  const debouncedSearch = useCallback(',
    '    debounceAsync((term: string) => {',
    '      setSearchTerm(term);',
    '      setPage(1);',
    '    }, 300),',
    '    []',
    '  );',
    '',
    '  useEffect(() => {',
    '    loadUsers();',
    '  }, [loadUsers]);',
    '',
    '  const handleUserClick = (user: User) => {',
    '    onUserSelect?.(user);',
    '  };',
    '',
    '  const handleSearch = (event: React.ChangeEvent<HTMLInputElement>) => {',
    '    debouncedSearch(event.target.value);',
    '  };',
    '',
    '  const handlePageChange = (newPage: number) => {',
    '    setPage(newPage);',
    '  };',
    '',
    '  if (loading) {',
    '    return <div className="loading">Loading users...</div>;',
    '  }',
    '',
    '  if (error) {',
    '    return <div className="error">Error: {error}</div>;',
    '  }',
    '',
    '  return (',
    '    <div className="user-list">',
    '      <div className="search-bar">',
    '        <input',
    '          type="text"',
    '          placeholder="Search users..."',
    '          onChange={handleSearch}',
    '          className="search-input"',
    '        />',
    '      </div>',
    '      ',
    '      <div className="user-grid">',
    '        {users.map(user => (',
    '          <div',
    '            key={user.id}',
    '            className="user-card"',
    '            onClick={() => handleUserClick(user)}',
    '          >',
    "            <img src={user.avatar || '/default-avatar.png'} alt={user.name} />",
    '            <h3>{user.name}</h3>',
    '            <p>{user.email}</p>',
    '            <small>Created: {formatDate(user.createdAt)}</small>',
    '          </div>',
    '        ))}',
    '      </div>',
    '      ',
    '      <div className="pagination">',
    '        <button',
    '          onClick={() => handlePageChange(page - 1)}',
    '          disabled={page <= 1}',
    '        >',
    '          Previous',
    '        </button>',
    '        <span className="page-info">Page {page}</span>',
    '        <button onClick={() => handlePageChange(page + 1)}>',
    '          Next',
    '        </button>',
    '      </div>',
    '    </div>',
    '  );',
    '};',
  ];

  const exports = [
    'export { User, UserRole, ApiResponse };',
    'export { UserService };',
    'export { UserList };',
    'export { formatDate, validateEmail, generateId, debounceAsync };',
  ];

  // Combine all sections and pad to reach desired line count
  let content = [
    ...imports,
    '',
    ...interfaces,
    '',
    ...utilityFunctions,
    '',
    ...complexClass,
    '',
    ...reactComponent,
    '',
    ...exports,
  ].join('\n');

  // Add padding lines if needed
  const currentLines = content.split('\n').length;
  if (currentLines < lineCount) {
    const paddingLines = lineCount - currentLines;
    const padding = Array.from(
      { length: paddingLines },
      (_, i) => `// Padding line ${i + 1} to reach ${lineCount} total lines`,
    ).join('\n');
    content += '\n' + padding;
  }

  return content;
}

/**
 * Generate large Python files with realistic structure
 */
export function generateLargePythonFile(lineCount: number): string {
  const imports = [
    'import os',
    'import sys',
    'import json',
    'import asyncio',
    'import logging',
    'from typing import List, Dict, Optional, Any, Union, Tuple',
    'from dataclasses import dataclass, field',
    'from datetime import datetime, timedelta',
    'from pathlib import Path',
    'import aiohttp',
    'import aiofiles',
    'from pydantic import BaseModel, validator',
  ];

  const classes = [
    '@dataclass',
    'class User:',
    '    id: int',
    '    name: str',
    '    email: str',
    '    avatar: Optional[str] = None',
    '    created_at: datetime = field(default_factory=datetime.now)',
    '    updated_at: Optional[datetime] = None',
    "    roles: List['UserRole'] = field(default_factory=list)",
    '',
    '    def __post_init__(self):',
    '        if isinstance(self.created_at, str):',
    '            self.created_at = datetime.fromisoformat(self.created_at)',
    '',
    '@dataclass',
    'class UserRole:',
    '    id: int',
    '    name: str',
    '    permissions: List[str] = field(default_factory=list)',
    '',
    'class UserModel(BaseModel):',
    '    id: int',
    '    name: str',
    '    email: str',
    '    avatar: Optional[str] = None',
    '    created_at: datetime',
    '    updated_at: Optional[datetime] = None',
    '    roles: List[Dict[str, Any]] = []',
    '',
    "    @validator('email')",
    '    def validate_email(cls, v):',
    '        import re',
    "        pattern = r'^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$'",
    '        if not re.match(pattern, v):',
    "            raise ValueError('Invalid email format')",
    '        return v',
  ];

  const utilityFunctions = [
    'def format_date(date: datetime) -> str:',
    '    """Format datetime to ISO string."""',
    '    return date.isoformat()',
    '',
    'def validate_email(email: str) -> bool:',
    '    """Validate email format."""',
    '    import re',
    "    pattern = r'^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$'",
    '    return bool(re.match(pattern, email))',
    '',
    'def generate_id() -> str:',
    '    """Generate random ID."""',
    '    import uuid',
    '    return str(uuid.uuid4())',
    '',
    'async def retry_async(',
    '    func,',
    '    *args,',
    '    retries: int = 3,',
    '    delay: float = 1.0,',
    '    **kwargs',
    '):',
    '    """Retry async function with exponential backoff."""',
    '    for attempt in range(retries):',
    '        try:',
    '            return await func(*args, **kwargs)',
    '        except Exception as e:',
    '            if attempt == retries - 1:',
    '                raise e',
    '            await asyncio.sleep(delay * (2 ** attempt))',
    '',
    "def setup_logging(level: str = 'INFO') -> logging.Logger:",
    '    """Setup logging configuration."""',
    '    logger = logging.getLogger(__name__)',
    '    logger.setLevel(getattr(logging, level.upper()))',
    '    ',
    '    handler = logging.StreamHandler()',
    '    formatter = logging.Formatter(',
    "        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'",
    '    )',
    '    handler.setFormatter(formatter)',
    '    logger.addHandler(handler)',
    '    ',
    '    return logger',
  ];

  const complexClass = [
    'class UserService:',
    '    """Service for managing users."""',
    '    ',
    '    def __init__(self, base_url: str, cache_ttl: int = 300):',
    "        self.base_url = base_url.rstrip('/')",
    '        self.cache: Dict[str, Any] = {}',
    '        self.cache_timestamps: Dict[str, datetime] = {}',
    '        self.cache_ttl = cache_ttl',
    '        self.logger = setup_logging()',
    '        self.session: Optional[aiohttp.ClientSession] = None',
    '',
    '    async def __aenter__(self):',
    '        self.session = aiohttp.ClientSession()',
    '        return self',
    '',
    '    async def __aexit__(self, exc_type, exc_val, exc_tb):',
    '        if self.session:',
    '            await self.session.close()',
    '',
    '    def _get_cache_key(self, **params) -> str:',
    '        """Generate cache key from parameters."""',
    '        import hashlib',
    '        param_str = json.dumps(params, sort_keys=True)',
    '        return hashlib.md5(param_str.encode()).hexdigest()',
    '',
    '    def _is_cache_valid(self, cache_key: str) -> bool:',
    '        """Check if cache entry is still valid."""',
    '        if cache_key not in self.cache_timestamps:',
    '            return False',
    '        age = datetime.now() - self.cache_timestamps[cache_key]',
    '        return age.total_seconds() < self.cache_ttl',
    '',
    '    async def get_users(',
    '        self,',
    '        page: int = 1,',
    '        limit: int = 20,',
    '        search: Optional[str] = None,',
    '        role: Optional[str] = None,',
    '    ) -> Dict[str, Any]:',
    '        """Get users with pagination and filtering."""',
    '        cache_key = self._get_cache_key(',
    '            page=page, limit=limit, search=search, role=role',
    '        )',
    '        ',
    '        if self._is_cache_valid(cache_key):',
    '            self.logger.debug(f"Cache hit for key: {cache_key}")',
    '            return self.cache[cache_key]',
    '',
    '        params = {',
    "            'page': page,",
    "            'limit': limit,",
    '        }',
    '        if search:',
    "            params['search'] = search",
    '        if role:',
    "            params['role'] = role",
    '',
    '        try:',
    '            if not self.session:',
    '                raise RuntimeError("Session not initialized. Use async context manager.")',
    '                ',
    '            async with self.session.get(',
    '                f"{self.base_url}/users", params=params',
    '            ) as response:',
    '                response.raise_for_status()',
    '                data = await response.json()',
    '                ',
    '                self.cache[cache_key] = data',
    '                self.cache_timestamps[cache_key] = datetime.now()',
    '                ',
    '                self.logger.info(f"Fetched {len(data.get(\'data\', []))} users")',
    '                return data',
    '                ',
    '        except aiohttp.ClientError as e:',
    '            self.logger.error(f"Error fetching users: {e}")',
    '            raise',
    '',
    '    async def create_user(self, user_data: Dict[str, Any]) -> Dict[str, Any]:',
    '        """Create a new user."""',
    '        try:',
    '            if not self.session:',
    '                raise RuntimeError("Session not initialized. Use async context manager.")',
    '                ',
    '            async with self.session.post(',
    '                f"{self.base_url}/users", json=user_data',
    '            ) as response:',
    '                response.raise_for_status()',
    '                data = await response.json()',
    '                ',
    '                # Clear cache after mutation',
    '                self.cache.clear()',
    '                self.cache_timestamps.clear()',
    '                ',
    '                self.logger.info(f"Created user with ID: {data.get(\'id\')}")',
    '                return data',
    '                ',
    '        except aiohttp.ClientError as e:',
    '            self.logger.error(f"Error creating user: {e}")',
    '            raise',
    '',
    '    async def update_user(',
    '        self, user_id: int, user_data: Dict[str, Any]',
    '    ) -> Dict[str, Any]:',
    '        """Update an existing user."""',
    '        try:',
    '            if not self.session:',
    '                raise RuntimeError("Session not initialized. Use async context manager.")',
    '                ',
    '            async with self.session.put(',
    '                f"{self.base_url}/users/{user_id}", json=user_data',
    '            ) as response:',
    '                response.raise_for_status()',
    '                data = await response.json()',
    '                ',
    '                # Clear cache after mutation',
    '                self.cache.clear()',
    '                self.cache_timestamps.clear()',
    '                ',
    '                self.logger.info(f"Updated user with ID: {user_id}")',
    '                return data',
    '                ',
    '        except aiohttp.ClientError as e:',
    '            self.logger.error(f"Error updating user: {e}")',
    '            raise',
    '',
    '    async def delete_user(self, user_id: int) -> None:',
    '        """Delete a user."""',
    '        try:',
    '            if not self.session:',
    '                raise RuntimeError("Session not initialized. Use async context manager.")',
    '                ',
    '            async with self.session.delete(f"{self.base_url}/users/{user_id}") as response:',
    '                response.raise_for_status()',
    '                ',
    '                # Clear cache after mutation',
    '                self.cache.clear()',
    '                self.cache_timestamps.clear()',
    '                ',
    '                self.logger.info(f"Deleted user with ID: {user_id}")',
    '                ',
    '        except aiohttp.ClientError as e:',
    '            self.logger.error(f"Error deleting user: {e}")',
    '            raise',
  ];

  const mainFunction = [
    'async def main():',
    '    """Main function demonstrating usage."""',
    "    logger = setup_logging('INFO')",
    '    ',
    '    # Example usage',
    "    async with UserService('https://api.example.com') as service:",
    '        try:',
    '            # Get users',
    '            users = await service.get_users(page=1, limit=10)',
    '            logger.info(f"Retrieved {len(users.get(\'data\', []))} users")',
    '            ',
    '            # Create user',
    '            new_user_data = {',
    "                'name': 'John Doe',",
    "                'email': 'john@example.com',",
    '            }',
    '            new_user = await service.create_user(new_user_data)',
    '            logger.info(f"Created user: {new_user.get(\'name\')}")',
    '            ',
    '            # Update user',
    "            update_data = {'name': 'Jane Doe'}",
    '            updated_user = await service.update_user(',
    "                new_user.get('id'), update_data",
    '            )',
    '            logger.info(f"Updated user: {updated_user.get(\'name\')}")',
    '            ',
    '            # Delete user',
    "            await service.delete_user(new_user.get('id'))",
    '            logger.info("Deleted user")',
    '            ',
    '        except Exception as e:',
    '            logger.error(f"Error in main: {e}")',
    '            raise',
    '',
    "if __name__ == '__main__':",
    '    asyncio.run(main())',
  ];

  // Combine all sections and pad to reach desired line count
  let content = [...imports, '', ...classes, '', ...utilityFunctions, '', ...complexClass, '', ...mainFunction].join(
    '\n',
  );

  // Add padding lines if needed
  const currentLines = content.split('\n').length;
  if (currentLines < lineCount) {
    const paddingLines = lineCount - currentLines;
    const padding = Array.from(
      { length: paddingLines },
      (_, i) => `# Padding line ${i + 1} to reach ${lineCount} total lines`,
    ).join('\n');
    content += '\n' + padding;
  }

  return content;
}

/**
 * Generate large Java files with realistic structure
 */
export function generateLargeJavaFile(lineCount: number): string {
  const packageAndImports = [
    'package com.example.service;',
    '',
    'import java.util.*;',
    'import java.util.concurrent.*;',
    'import java.util.stream.Collectors;',
    'import java.time.*;',
    'import java.time.format.*;',
    'import java.util.function.*;',
    'import java.util.logging.*;',
    'import org.springframework.data.domain.*;',
    'import org.springframework.stereotype.Service;',
    'import org.springframework.transaction.annotation.Transactional;',
    'import org.springframework.beans.factory.annotation.Autowired;',
    'import org.springframework.cache.annotation.Cacheable;',
    'import org.springframework.cache.annotation.CacheEvict;',
  ];

  const classes = [
    'public class User {',
    '    private Long id;',
    '    private String name;',
    '    private String email;',
    '    private String avatar;',
    '    private LocalDateTime createdAt;',
    '    private LocalDateTime updatedAt;',
    '    private Set<UserRole> roles = new HashSet<>();',
    '',
    '    public User() {',
    '        this.createdAt = LocalDateTime.now();',
    '    }',
    '',
    '    public User(String name, String email) {',
    '        this();',
    '        this.name = name;',
    '        this.email = email;',
    '    }',
    '',
    '    // Getters and setters',
    '    public Long getId() { return id; }',
    '    public void setId(Long id) { this.id = id; }',
    '',
    '    public String getName() { return name; }',
    '    public void setName(String name) { this.name = name; }',
    '',
    '    public String getEmail() { return email; }',
    '    public void setEmail(String email) { this.email = email; }',
    '',
    '    public String getAvatar() { return avatar; }',
    '    public void setAvatar(String avatar) { this.avatar = avatar; }',
    '',
    '    public LocalDateTime getCreatedAt() { return createdAt; }',
    '    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }',
    '',
    '    public LocalDateTime getUpdatedAt() { return updatedAt; }',
    '    public void setUpdatedAt(LocalDateTime updatedAt) { this.updatedAt = updatedAt; }',
    '',
    '    public Set<UserRole> getRoles() { return roles; }',
    '    public void setRoles(Set<UserRole> roles) { this.roles = roles; }',
    '',
    '    @Override',
    '    public boolean equals(Object o) {',
    '        if (this == o) return true;',
    '        if (o == null || getClass() != o.getClass()) return false;',
    '        User user = (User) o;',
    '        return Objects.equals(id, user.id);',
    '    }',
    '',
    '    @Override',
    '    public int hashCode() {',
    '        return Objects.hash(id);',
    '    }',
    '',
    '    @Override',
    '    public String toString() {',
    '        return "User{" +',
    '                "id=" + id +',
    "                \", name='\" + name + '\\'' +",
    "                \", email='\" + email + '\\'' +",
    '                ", createdAt=" + createdAt +',
    "                '}';",
    '    }',
    '}',
    '',
    'public class UserRole {',
    '    private Long id;',
    '    private String name;',
    '    private Set<String> permissions = new HashSet<>();',
    '',
    '    public UserRole() {}',
    '',
    '    public UserRole(String name) {',
    '        this.name = name;',
    '    }',
    '',
    '    // Getters and setters',
    '    public Long getId() { return id; }',
    '    public void setId(Long id) { this.id = id; }',
    '',
    '    public String getName() { return name; }',
    '    public void setName(String name) { this.name = name; }',
    '',
    '    public Set<String> getPermissions() { return permissions; }',
    '    public void setPermissions(Set<String> permissions) { this.permissions = permissions; }',
    '}',
  ];

  const utilityClasses = [
    'public class DateUtils {',
    '    private static final DateTimeFormatter DEFAULT_FORMATTER = ',
    '        DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");',
    '',
    '    public static String formatDateTime(LocalDateTime dateTime) {',
    '        return dateTime != null ? dateTime.format(DEFAULT_FORMATTER) : null;',
    '    }',
    '',
    '    public static LocalDateTime parseDateTime(String dateTimeStr) {',
    '        try {',
    '            return LocalDateTime.parse(dateTimeStr, DEFAULT_FORMATTER);',
    '        } catch (DateTimeParseException e) {',
    '            return null;',
    '        }',
    '    }',
    '',
    '    public static boolean isEmailValid(String email) {',
    '        if (email == null || email.trim().isEmpty()) {',
    '            return false;',
    '        }',
    '        return email.matches("^[^\\\\s@]+@[^\\\\s@]+\\\\.[^\\\\s]+$");',
    '    }',
    '',
    '    public static String generateId() {',
    '        return UUID.randomUUID().toString();',
    '    }',
    '}',
    '',
    'public class RetryUtils {',
    '    private static final Logger logger = Logger.getLogger(RetryUtils.class.getName());',
    '',
    '    public static <T> T retryWithBackoff(',
    '        Supplier<T> operation,',
    '        int maxAttempts,',
    '        long initialDelayMs',
    '    ) {',
    '        Exception lastException = null;',
    '        long delay = initialDelayMs;',
    '',
    '        for (int attempt = 1; attempt <= maxAttempts; attempt++) {',
    '            try {',
    '                return operation.get();',
    '            } catch (Exception e) {',
    '                lastException = e;',
    '                logger.warning(String.format(',
    '                    "Attempt %d failed: %s", attempt, e.getMessage()',
    '                ));',
    '',
    '                if (attempt < maxAttempts) {',
    '                    try {',
    '                        Thread.sleep(delay);',
    '                    } catch (InterruptedException ie) {',
    '                        Thread.currentThread().interrupt();',
    '                        throw new RuntimeException("Interrupted during retry delay", ie);',
    '                    }',
    '                    delay *= 2; // Exponential backoff',
    '                }',
    '            }',
    '        }',
    '',
    '        throw new RuntimeException(',
    '            String.format("Operation failed after %d attempts", maxAttempts),',
    '            lastException',
    '        );',
    '    }',
    '}',
  ];

  const serviceClass = [
    '@Service',
    '@Transactional',
    'public class UserService {',
    '    private static final Logger logger = Logger.getLogger(UserService.class.getName());',
    '    ',
    '    @Autowired',
    '    private UserRepository userRepository;',
    '    ',
    '    @Autowired',
    '    private RoleRepository roleRepository;',
    '    ',
    '    private final Map<String, Object> cache = new ConcurrentHashMap<>();',
    '    private final Map<String, Long> cacheTimestamps = new ConcurrentHashMap<>();',
    '    private static final long CACHE_TTL_MS = 300000; // 5 minutes',
    '',
    "    @Cacheable(value = \"users\", key = \"#page + '_' + #limit + '_' + #search + '_' + #role\")",
    '    public Page<User> getUsers(int page, int limit, String search, String role) {',
    '        String cacheKey = generateCacheKey(page, limit, search, role);',
    '        ',
    '        // Check cache first',
    '        if (isCacheValid(cacheKey)) {',
    '            logger.info(String.format("Cache hit for key: %s", cacheKey));',
    '            return (Page<User>) cache.get(cacheKey);',
    '        }',
    '',
    '        try {',
    '            Pageable pageable = PageRequest.of(page - 1, limit, ',
    '                Sort.by("createdAt").descending());',
    '            ',
    '            Page<User> result;',
    '            if (search != null && !search.trim().isEmpty()) {',
    '                result = userRepository.findByNameContainingIgnoreCase(search, pageable);',
    '            } else if (role != null && !role.trim().isEmpty()) {',
    '                result = userRepository.findByRolesName(role, pageable);',
    '            } else {',
    '                result = userRepository.findAll(pageable);',
    '            }',
    '            ',
    '            // Cache the result',
    '            cache.put(cacheKey, result);',
    '            cacheTimestamps.put(cacheKey, System.currentTimeMillis());',
    '            ',
    '            logger.info(String.format("Retrieved %d users", result.getContent().size()));',
    '            return result;',
    '            ',
    '        } catch (Exception e) {',
    '            logger.severe(String.format("Error fetching users: %s", e.getMessage()));',
    '            throw new ServiceException("Failed to fetch users", e);',
    '        }',
    '    }',
    '',
    '    @CacheEvict(value = "users", allEntries = true)',
    '    public User createUser(User user) {',
    '        try {',
    '            if (!DateUtils.isEmailValid(user.getEmail())) {',
    '                throw new ValidationException("Invalid email format");',
    '            }',
    '            ',
    '            user.setUpdatedAt(LocalDateTime.now());',
    '            User savedUser = userRepository.save(user);',
    '            ',
    '            logger.info(String.format("Created user with ID: %d", savedUser.getId()));',
    '            return savedUser;',
    '            ',
    '        } catch (Exception e) {',
    '            logger.severe(String.format("Error creating user: %s", e.getMessage()));',
    '            throw new ServiceException("Failed to create user", e);',
    '        }',
    '    }',
    '',
    '    @CacheEvict(value = "users", allEntries = true)',
    '    public User updateUser(Long userId, User userData) {',
    '        return RetryUtils.retryWithBackoff(() -> {',
    '            try {',
    '                User existingUser = userRepository.findById(userId)',
    '                    .orElseThrow(() -> new EntityNotFoundException(',
    '                        String.format("User not found with ID: %d", userId)',
    '                    ));',
    '                ',
    '                if (userData.getName() != null) {',
    '                    existingUser.setName(userData.getName());',
    '                }',
    '                if (userData.getEmail() != null) {',
    '                    if (!DateUtils.isEmailValid(userData.getEmail())) {',
    '                        throw new ValidationException("Invalid email format");',
    '                    }',
    '                    existingUser.setEmail(userData.getEmail());',
    '                }',
    '                if (userData.getAvatar() != null) {',
    '                    existingUser.setAvatar(userData.getAvatar());',
    '                }',
    '                ',
    '                existingUser.setUpdatedAt(LocalDateTime.now());',
    '                User updatedUser = userRepository.save(existingUser);',
    '                ',
    '                logger.info(String.format("Updated user with ID: %d", userId));',
    '                return updatedUser;',
    '                ',
    '            } catch (Exception e) {',
    '                logger.severe(String.format("Error updating user: %s", e.getMessage()));',
    '                throw new ServiceException("Failed to update user", e);',
    '            }',
    '        }, 3, 1000);',
    '    }',
    '',
    '    @CacheEvict(value = "users", allEntries = true)',
    '    public void deleteUser(Long userId) {',
    '        try {',
    '            if (!userRepository.existsById(userId)) {',
    '                throw new EntityNotFoundException(',
    '                    String.format("User not found with ID: %d", userId)',
    '                );',
    '            }',
    '            ',
    '            userRepository.deleteById(userId);',
    '            logger.info(String.format("Deleted user with ID: %d", userId));',
    '            ',
    '        } catch (Exception e) {',
    '            logger.severe(String.format("Error deleting user: %s", e.getMessage()));',
    '            throw new ServiceException("Failed to delete user", e);',
    '        }',
    '    }',
    '',
    '    private String generateCacheKey(int page, int limit, String search, String role) {',
    '        return String.format("users_%d_%d_%s_%s", page, limit, ',
    '            search != null ? search : "", role != null ? role : "");',
    '    }',
    '',
    '    private boolean isCacheValid(String cacheKey) {',
    '        Long timestamp = cacheTimestamps.get(cacheKey);',
    '        return timestamp != null && ',
    '            (System.currentTimeMillis() - timestamp) < CACHE_TTL_MS;',
    '    }',
    '',
    '    @Scheduled(fixedRate = CACHE_TTL_MS)',
    '    public void cleanupCache() {',
    '        long currentTime = System.currentTimeMillis();',
    '        cacheTimestamps.entrySet().removeIf(entry -> ',
    '            (currentTime - entry.getValue()) >= CACHE_TTL_MS);',
    '        cache.keySet().removeIf(key -> !cacheTimestamps.containsKey(key));',
    '        logger.info("Cache cleanup completed");',
    '    }',
    '}',
  ];

  const exceptions = [
    'public class ServiceException extends RuntimeException {',
    '    public ServiceException(String message) {',
    '        super(message);',
    '    }',
    '',
    '    public ServiceException(String message, Throwable cause) {',
    '        super(message, cause);',
    '    }',
    '}',
    '',
    'public class ValidationException extends RuntimeException {',
    '    public ValidationException(String message) {',
    '        super(message);',
    '    }',
    '}',
    '',
    'public class EntityNotFoundException extends RuntimeException {',
    '    public EntityNotFoundException(String message) {',
    '        super(message);',
    '    }',
    '}',
  ];

  // Combine all sections and pad to reach desired line count
  let content = [
    ...packageAndImports,
    '',
    ...classes,
    '',
    ...utilityClasses,
    '',
    ...serviceClass,
    '',
    ...exceptions,
  ].join('\n');

  // Add padding lines if needed
  const currentLines = content.split('\n').length;
  if (currentLines < lineCount) {
    const paddingLines = lineCount - currentLines;
    const padding = Array.from(
      { length: paddingLines },
      (_, i) => `// Padding line ${i + 1} to reach ${lineCount} total lines`,
    ).join('\n');
    content += '\n' + padding;
  }

  return content;
}

/**
 * Generate large Go files with realistic structure
 */
export function generateLargeGoFile(lineCount: number): string {
  const packageAndImports = [
    'package main',
    '',
    'import (',
    '\t"context"',
    '\t"encoding/json"',
    '\t"fmt"',
    '\t"log"',
    '\t"net/http"',
    '\t"strconv"',
    '\t"strings"',
    '\t"time"',
    '\t"sync"',
    '\t"crypto/md5"',
    '\t"io"',
    '\t"os"',
    '\t"regexp"',
    '\t"github.com/gorilla/mux"',
    ')',
  ];

  const structs = [
    'type User struct {',
    '\tID        int64     `json:"id"`',
    '\tName      string    `json:"name"`',
    '\tEmail     string    `json:"email"`',
    '\tAvatar    *string   `json:"avatar,omitempty"`',
    '\tCreatedAt time.Time `json:"created_at"`',
    '\tUpdatedAt *time.Time `json:"updated_at,omitempty"`',
    '\tRoles     []UserRole `json:"roles"`',
    '}',
    '',
    'type UserRole struct {',
    '\tID          int64    `json:"id"`',
    '\tName        string   `json:"name"`',
    '\tPermissions []string `json:"permissions"`',
    '}',
    '',
    'type CreateUserRequest struct {',
    '\tName  string `json:"name" validate:"required"`',
    '\tEmail string `json:"email" validate:"required,email"`',
    '}',
    '',
    'type UpdateUserRequest struct {',
    '\tName   *string `json:"name,omitempty" validate:"omitempty"`',
    '\tEmail  *string `json:"email,omitempty" validate:"omitempty,email"`',
    '\tAvatar *string `json:"avatar,omitempty"`',
    '}',
    '',
    'type UserResponse struct {',
    '\tSuccess bool        `json:"success"`',
    '\tData    interface{} `json:"data,omitempty"`',
    '\tMessage string      `json:"message,omitempty"`',
    '\tError   string      `json:"error,omitempty"`',
    '}',
    '',
    'type PaginatedUsersResponse struct {',
    '\tSuccess bool        `json:"success"`',
    '\tData    []User      `json:"data"`',
    '\tPage    int         `json:"page"`',
    '\tLimit   int         `json:"limit"`',
    '\tTotal   int64       `json:"total"`',
    '\tMessage string      `json:"message,omitempty"`',
    '}',
    '',
    'type UserService struct {',
    '\tbaseUrl string',
    '\tcache   map[string]cacheEntry',
    '\tmu      sync.RWMutex',
    '\tlogger  *log.Logger',
    '}',
    '',
    'type cacheEntry struct {',
    '\tdata      interface{}',
    '\ttimestamp time.Time',
    '}',
  ];

  const utilityFunctions = [
    'func formatDate(t time.Time) string {',
    '\treturn t.Format("2006-01-02 15:04:05")',
    '}',
    '',
    'func isValidEmail(email string) bool {',
    '\tconst emailRegex = `^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$`',
    '\tmatched, err := regexp.MatchString(emailRegex, email)',
    '\tif err != nil {',
    '\t\treturn false',
    '\t}',
    '\treturn matched',
    '}',
    '',
    'func generateID() string {',
    '\th := md5.New()',
    '\tio.WriteString(h, time.Now().String())',
    '\treturn fmt.Sprintf("%x", h.Sum(nil))',
    '}',
    '',
    'func generateCacheKey(params map[string]interface{}) string {',
    '\tkey := make([]string, 0, len(params))',
    '\tfor k, v := range params {',
    '\t\tkey = append(key, fmt.Sprintf("%s=%v", k, v))',
    '\t}',
    '\tsort.Strings(key)',
    '\treturn strings.Join(key, "&")',
    '}',
    '',
    'func retryWithBackoff(operation func() error, maxAttempts int, initialDelay time.Duration) error {',
    '\tvar lastErr error',
    '\tdelay := initialDelay',
    '',
    '\tfor attempt := 1; attempt <= maxAttempts; attempt++ {',
    '\t\tif err := operation(); err != nil {',
    '\t\t\tlastErr = err',
    '\t\t\tlog.Printf("Attempt %d failed: %v", attempt, err)',
    '',
    '\t\t\tif attempt < maxAttempts {',
    '\t\t\t\ttime.Sleep(delay)',
    '\t\t\t\tdelay *= 2 // Exponential backoff',
    '\t\t\t}',
    '\t\t} else {',
    '\t\t\treturn nil',
    '\t\t}',
    '\t}',
    '',
    '\treturn fmt.Errorf("operation failed after %d attempts: %w", maxAttempts, lastErr)',
    '}',
    '',
    'func writeJSONResponse(w http.ResponseWriter, status int, data interface{}) {',
    '\tw.Header().Set("Content-Type", "application/json")',
    '\tw.WriteHeader(status)',
    '\tif err := json.NewEncoder(w).Encode(data); err != nil {',
    '\t\tlog.Printf("Error encoding JSON response: %v", err)',
    '\t}',
    '}',
    '',
    'func writeErrorResponse(w http.ResponseWriter, status int, message string) {',
    '\tresponse := UserResponse{',
    '\t\tSuccess: false,',
    '\t\tError:   message,',
    '\t}',
    '\twriteJSONResponse(w, status, response)',
    '}',
  ];

  const serviceMethods = [
    'func NewUserService(baseUrl string) *UserService {',
    '\treturn &UserService{',
    '\t\tbaseUrl: baseUrl,',
    '\t\tcache:   make(map[string]cacheEntry),',
    '\t\tlogger:  log.New(os.Stdout, "[UserService] ", log.LstdFlags),',
    '\t}',
    '}',
    '',
    'func (s *UserService) isCacheValid(key string) bool {',
    '\ts.mu.RLock()',
    '\tdefer s.mu.RUnlock()',
    '',
    '\tentry, exists := s.cache[key]',
    '\tif !exists {',
    '\t\treturn false',
    '\t}',
    '',
    '\t// Cache TTL: 5 minutes',
    '\treturn time.Since(entry.timestamp) < 5*time.Minute',
    '}',
    '',
    'func (s *UserService) setCache(key string, data interface{}) {',
    '\ts.mu.Lock()',
    '\tdefer s.mu.Unlock()',
    '',
    '\ts.cache[key] = cacheEntry{',
    '\t\tdata:      data,',
    '\t\ttimestamp: time.Now(),',
    '\t}',
    '}',
    '',
    'func (s *UserService) clearCache() {',
    '\ts.mu.Lock()',
    '\tdefer s.mu.Unlock()',
    '',
    '\ts.cache = make(map[string]cacheEntry)',
    '}',
    '',
    'func (s *UserService) GetUsers(page, limit int, search, role string) (*PaginatedUsersResponse, error) {',
    '\tcacheKey := generateCacheKey(map[string]interface{}{',
    '\t\t"page":   page,',
    '\t\t"limit":  limit,',
    '\t\t"search": search,',
    '\t\t"role":   role,',
    '\t})',
    '',
    '\tif s.isCacheValid(cacheKey) {',
    '\t\ts.logger.Printf("Cache hit for key: %s", cacheKey)',
    '\t\tif entry, exists := s.cache[cacheKey]; exists {',
    '\t\t\treturn entry.data.(*PaginatedUsersResponse), nil',
    '\t\t}',
    '\t}',
    '',
    '\t// Simulate API call',
    '\turl := fmt.Sprintf("%s/users?page=%d&limit=%d", s.baseUrl, page, limit)',
    '\tif search != "" {',
    '\t\turl += fmt.Sprintf("&search=%s", search)',
    '\t}',
    '\tif role != "" {',
    '\t\turl += fmt.Sprintf("&role=%s", role)',
    '\t}',
    '',
    '\tresp, err := http.Get(url)',
    '\tif err != nil {',
    '\t\treturn nil, fmt.Errorf("failed to fetch users: %w", err)',
    '\t}',
    '\tdefer resp.Body.Close()',
    '',
    '\tif resp.StatusCode != http.StatusOK {',
    '\t\treturn nil, fmt.Errorf("API returned status %d", resp.StatusCode)',
    '\t}',
    '',
    '\tvar result PaginatedUsersResponse',
    '\tif err := json.NewDecoder(resp.Body).Decode(&result); err != nil {',
    '\t\treturn nil, fmt.Errorf("failed to decode response: %w", err)',
    '\t}',
    '',
    '\tresult.Success = true',
    '\ts.setCache(cacheKey, &result)',
    '\ts.logger.Printf("Fetched %d users", len(result.Data))',
    '',
    '\treturn &result, nil',
    '}',
    '',
    'func (s *UserService) CreateUser(req CreateUserRequest) (*UserResponse, error) {',
    '\tif !isValidEmail(req.Email) {',
    '\t\treturn nil, fmt.Errorf("invalid email format")',
    '\t}',
    '',
    '\tjsonData, err := json.Marshal(req)',
    '\tif err != nil {',
    '\t\treturn nil, fmt.Errorf("failed to marshal request: %w", err)',
    '\t}',
    '',
    '\turl := fmt.Sprintf("%s/users", s.baseUrl)',
    '\tresp, err := http.Post(url, "application/json", strings.NewReader(string(jsonData)))',
    '\tif err != nil {',
    '\t\treturn nil, fmt.Errorf("failed to create user: %w", err)',
    '\t}',
    '\tdefer resp.Body.Close()',
    '',
    '\tif resp.StatusCode != http.StatusCreated {',
    '\t\treturn nil, fmt.Errorf("API returned status %d", resp.StatusCode)',
    '\t}',
    '',
    '\tvar user User',
    '\tif err := json.NewDecoder(resp.Body).Decode(&user); err != nil {',
    '\t\treturn nil, fmt.Errorf("failed to decode response: %w", err)',
    '\t}',
    '',
    '\ts.clearCache() // Clear cache after mutation',
    '\ts.logger.Printf("Created user with ID: %d", user.ID)',
    '',
    '\treturn &UserResponse{',
    '\t\tSuccess: true,',
    '\t\tData:    user,',
    '\t\tMessage: "User created successfully",',
    '\t}, nil',
    '}',
    '',
    'func (s *UserService) UpdateUser(userID int64, req UpdateUserRequest) (*UserResponse, error) {',
    '\treturn nil, retryWithBackoff(func() error {',
    '\t\tjsonData, err := json.Marshal(req)',
    '\t\tif err != nil {',
    '\t\t\treturn fmt.Errorf("failed to marshal request: %w", err)',
    '\t\t}',
    '',
    '\t\turl := fmt.Sprintf("%s/users/%d", s.baseUrl, userID)',
    '\t\thttpReq, err := http.NewRequest("PUT", url, strings.NewReader(string(jsonData)))',
    '\t\tif err != nil {',
    '\t\t\treturn fmt.Errorf("failed to create request: %w", err)',
    '\t\t}',
    '\t\thttpReq.Header.Set("Content-Type", "application/json")',
    '',
    '\t\tclient := &http.Client{Timeout: 30 * time.Second}',
    '\t\tresp, err := client.Do(httpReq)',
    '\t\tif err != nil {',
    '\t\t\treturn fmt.Errorf("failed to update user: %w", err)',
    '\t\t}',
    '\t\tdefer resp.Body.Close()',
    '',
    '\t\tif resp.StatusCode != http.StatusOK {',
    '\t\t\treturn fmt.Errorf("API returned status %d", resp.StatusCode)',
    '\t\t}',
    '',
    '\t\tvar user User',
    '\t\tif err := json.NewDecoder(resp.Body).Decode(&user); err != nil {',
    '\t\t\treturn fmt.Errorf("failed to decode response: %w", err)',
    '\t\t}',
    '',
    '\t\ts.clearCache() // Clear cache after mutation',
    '\t\ts.logger.Printf("Updated user with ID: %d", userID)',
    '\t\treturn nil',
    '\t}, 3, time.Second)',
    '}',
    '',
    'func (s *UserService) DeleteUser(userID int64) error {',
    '\turl := fmt.Sprintf("%s/users/%d", s.baseUrl, userID)',
    '\treq, err := http.NewRequest("DELETE", url, nil)',
    '\tif err != nil {',
    '\t\treturn fmt.Errorf("failed to create request: %w", err)',
    '\t}',
    '',
    '\tclient := &http.Client{Timeout: 30 * time.Second}',
    '\tresp, err := client.Do(req)',
    '\tif err != nil {',
    '\t\treturn fmt.Errorf("failed to delete user: %w", err)',
    '\t}',
    '\tdefer resp.Body.Close()',
    '',
    '\tif resp.StatusCode != http.StatusNoContent {',
    '\t\treturn fmt.Errorf("API returned status %d", resp.StatusCode)',
    '\t}',
    '',
    '\ts.clearCache() // Clear cache after mutation',
    '\ts.logger.Printf("Deleted user with ID: %d", userID)',
    '\treturn nil',
    '}',
  ];

  const httpHandlers = [
    'func (s *UserService) HandleUsers(w http.ResponseWriter, r *http.Request) {',
    '\tquery := r.URL.Query()',
    '\tpage, _ := strconv.Atoi(query.Get("page"))',
    '\tif page < 1 {',
    '\t\tpage = 1',
    '\t}',
    '',
    '\tlimit, _ := strconv.Atoi(query.Get("limit"))',
    '\tif limit < 1 || limit > 100 {',
    '\t\tlimit = 20',
    '\t}',
    '',
    '\tsearch := query.Get("search")',
    '\trole := query.Get("role")',
    '',
    '\tresult, err := s.GetUsers(page, limit, search, role)',
    '\tif err != nil {',
    '\t\twriteErrorResponse(w, http.StatusInternalServerError, err.Error())',
    '\t\treturn',
    '\t}',
    '',
    '\twriteJSONResponse(w, http.StatusOK, result)',
    '}',
    '',
    'func (s *UserService) HandleCreateUser(w http.ResponseWriter, r *http.Request) {',
    '\tvar req CreateUserRequest',
    '\tif err := json.NewDecoder(r.Body).Decode(&req); err != nil {',
    '\t\twriteErrorResponse(w, http.StatusBadRequest, "Invalid request body")',
    '\t\treturn',
    '\t}',
    '',
    '\tresult, err := s.CreateUser(req)',
    '\tif err != nil {',
    '\t\twriteErrorResponse(w, http.StatusInternalServerError, err.Error())',
    '\t\treturn',
    '\t}',
    '',
    '\twriteJSONResponse(w, http.StatusCreated, result)',
    '}',
    '',
    'func (s *UserService) HandleUpdateUser(w http.ResponseWriter, r *http.Request) {',
    '\tvars := mux.Vars(r)',
    '\tuserIDStr := vars["id"]',
    '\tuserID, err := strconv.ParseInt(userIDStr, 10, 64)',
    '\tif err != nil {',
    '\t\twriteErrorResponse(w, http.StatusBadRequest, "Invalid user ID")',
    '\t\treturn',
    '\t}',
    '',
    '\tvar req UpdateUserRequest',
    '\tif err := json.NewDecoder(r.Body).Decode(&req); err != nil {',
    '\t\twriteErrorResponse(w, http.StatusBadRequest, "Invalid request body")',
    '\t\treturn',
    '\t}',
    '',
    '\tresult, err := s.UpdateUser(userID, req)',
    '\tif err != nil {',
    '\t\twriteErrorResponse(w, http.StatusInternalServerError, err.Error())',
    '\t\treturn',
    '\t}',
    '',
    '\twriteJSONResponse(w, http.StatusOK, result)',
    '}',
    '',
    'func (s *UserService) HandleDeleteUser(w http.ResponseWriter, r *http.Request) {',
    '\tvars := mux.Vars(r)',
    '\tuserIDStr := vars["id"]',
    '\tuserID, err := strconv.ParseInt(userIDStr, 10, 64)',
    '\tif err != nil {',
    '\t\twriteErrorResponse(w, http.StatusBadRequest, "Invalid user ID")',
    '\t\treturn',
    '\t}',
    '',
    '\tif err := s.DeleteUser(userID); err != nil {',
    '\t\twriteErrorResponse(w, http.StatusInternalServerError, err.Error())',
    '\t\treturn',
    '\t}',
    '',
    '\twriteJSONResponse(w, http.StatusNoContent, UserResponse{Success: true})',
    '}',
  ];

  const mainFunction = [
    'func main() {',
    '\tservice := NewUserService("https://api.example.com")',
    '\trouter := mux.NewRouter()',
    '',
    '\t// API routes',
    '\trouter.HandleFunc("/users", service.HandleUsers).Methods("GET")',
    '\trouter.HandleFunc("/users", service.HandleCreateUser).Methods("POST")',
    '\trouter.HandleFunc("/users/{id}", service.HandleUpdateUser).Methods("PUT")',
    '\trouter.HandleFunc("/users/{id}", service.HandleDeleteUser).Methods("DELETE")',
    '',
    '\t// Start server',
    '\tport := ":8080"',
    '\tservice.logger.Printf("Starting server on port %s", port)',
    '',
    '\tif err := http.ListenAndServe(port, router); err != nil {',
    '\t\tlog.Fatalf("Failed to start server: %v", err)',
    '\t}',
    '}',
  ];

  // Combine all sections and pad to reach desired line count
  let content = [
    ...packageAndImports,
    '',
    ...structs,
    '',
    ...utilityFunctions,
    '',
    ...serviceMethods,
    '',
    ...httpHandlers,
    '',
    ...mainFunction,
  ].join('\n');

  // Add padding lines if needed
  const currentLines = content.split('\n').length;
  if (currentLines < lineCount) {
    const paddingLines = lineCount - currentLines;
    const padding = Array.from(
      { length: paddingLines },
      (_, i) => `// Padding line ${i + 1} to reach ${lineCount} total lines`,
    ).join('\n');
    content += '\n' + padding;
  }

  return content;
}

/**
 * Generate large files for different languages
 */
export function generateLargeFile(language: SupportedLang, lineCount: number): string {
  switch (language) {
    case 'javascript':
    case 'typescript':
      return generateLargeJavaScriptFile(lineCount);
    case 'python':
      return generateLargePythonFile(lineCount);
    case 'java':
      return generateLargeJavaFile(lineCount);
    case 'go':
      return generateLargeGoFile(lineCount);
    default:
      // For other languages, generate a generic file with padding
      return generateGenericLargeFile(lineCount, language);
  }
}

/**
 * Generate generic large file for unsupported languages
 */
function generateGenericLargeFile(lineCount: number, language: SupportedLang): string {
  const header = [
    `// Generated ${language} file for performance testing`,
    `// Line count: ${lineCount}`,
    `// Language: ${language}`,
    '',
    '// This is a generated file for performance testing purposes.',
    '// It contains realistic code structure patterns for the specified language.',
    '',
  ];

  const functions = Array.from({ length: Math.min(20, Math.floor(lineCount / 10)) }, (_, i) => [
    `function function${i + 1}(param1, param2, param3) {`,
    '  // Function implementation',
    '  let result = param1 + param2 + param3;',
    '  ',
    '  // Some complex logic',
    '  for (let i = 0; i < 100; i++) {',
    '    result += Math.random();',
    '  }',
    '  ',
    '  // Conditional logic',
    '  if (result > 0) {',
    '    return result * 2;',
    '  } else {',
    '    return Math.abs(result);',
    '  }',
    '}',
    '',
  ]).flat();

  const classes = Array.from({ length: Math.min(5, Math.floor(lineCount / 50)) }, (_, i) => [
    `class Class${i + 1} {`,
    '  constructor() {',
    "    this.property1 = 'value1';",
    "    this.property2 = 'value2';",
    '    this.property3 = [];',
    '  }',
    '',
    '  method1() {',
    '    return this.property1;',
    '  }',
    '',
    '  method2() {',
    '    return this.property2;',
    '  }',
    '',
    '  method3() {',
    '    return this.property3;',
    '  }',
    '}',
    '',
  ]).flat();

  let content = [...header, ...functions, ...classes].join('\n');

  // Add padding lines if needed
  const currentLines = content.split('\n').length;
  if (currentLines < lineCount) {
    const paddingLines = lineCount - currentLines;
    const padding = Array.from(
      { length: paddingLines },
      (_, i) => `// Padding line ${i + 1} to reach ${lineCount} total lines for ${language}`,
    ).join('\n');
    content += '\n' + padding;
  }

  return content;
}

/**
 * Generate test cases for performance testing
 */
export function generatePerformanceTestCases(): PerformanceTestCase[] {
  return [
    // Small files (< 100 lines)
    { language: 'javascript', lineCount: 50, lineLimit: 10, expectedMaxTimeMs: 50, expectedMaxMemoryMB: 10 },
    { language: 'python', lineCount: 75, lineLimit: 15, expectedMaxTimeMs: 75, expectedMaxMemoryMB: 10 },
    { language: 'java', lineCount: 90, lineLimit: 20, expectedMaxTimeMs: 90, expectedMaxMemoryMB: 10 },

    // Medium files (100-1000 lines)
    { language: 'typescript', lineCount: 250, lineLimit: 50, expectedMaxTimeMs: 250, expectedMaxMemoryMB: 20 },
    { language: 'python', lineCount: 500, lineLimit: 100, expectedMaxTimeMs: 500, expectedMaxMemoryMB: 20 },
    { language: 'java', lineCount: 750, lineLimit: 150, expectedMaxTimeMs: 750, expectedMaxMemoryMB: 20 },
    { language: 'go', lineCount: 1000, lineLimit: 200, expectedMaxTimeMs: 1000, expectedMaxMemoryMB: 20 },

    // Large files (1000-10000 lines)
    { language: 'javascript', lineCount: 2000, lineLimit: 200, expectedMaxTimeMs: 2000, expectedMaxMemoryMB: 50 },
    { language: 'typescript', lineCount: 3500, lineLimit: 350, expectedMaxTimeMs: 3500, expectedMaxMemoryMB: 50 },
    { language: 'python', lineCount: 5000, lineLimit: 500, expectedMaxTimeMs: 5000, expectedMaxMemoryMB: 50 },
    { language: 'java', lineCount: 7500, lineLimit: 750, expectedMaxTimeMs: 7500, expectedMaxMemoryMB: 50 },
    { language: 'go', lineCount: 10000, lineLimit: 1000, expectedMaxTimeMs: 10000, expectedMaxMemoryMB: 50 },

    // Very large files (> 10000 lines)
    { language: 'javascript', lineCount: 15000, lineLimit: 1500, expectedMaxTimeMs: 15000, expectedMaxMemoryMB: 100 },
    { language: 'python', lineCount: 25000, lineLimit: 2500, expectedMaxTimeMs: 25000, expectedMaxMemoryMB: 100 },
    { language: 'java', lineCount: 35000, lineLimit: 3500, expectedMaxTimeMs: 35000, expectedMaxMemoryMB: 100 },
    { language: 'go', lineCount: 50000, lineLimit: 5000, expectedMaxTimeMs: 50000, expectedMaxMemoryMB: 100 },
  ];
}

/**
 * Generate multiple files for scalability testing
 */
export function generateFileSet(count: number, language: SupportedLang, linesPerFile: number): GeneratedFile[] {
  const files: GeneratedFile[] = [];

  for (let i = 1; i <= count; i++) {
    const content = generateLargeFile(language, linesPerFile);
    const extension = getFileExtension(language);
    const filePath = `test-${i}.${extension}`;

    files.push({
      content,
      filePath,
      language,
      actualLineCount: content.split('\n').length,
    });
  }

  return files;
}

/**
 * Get file extension for language
 */
function getFileExtension(language: SupportedLang): string {
  const extensions: Record<string, string> = {
    javascript: 'js',
    typescript: 'ts',
    python: 'py',
    java: 'java',
    go: 'go',
    c: 'c',
    cpp: 'cpp',
    c_sharp: 'cs',
    rust: 'rs',
    php: 'php',
    ruby: 'rb',
    swift: 'swift',
    solidity: 'sol',
    css: 'css',
    vue: 'vue',
    dart: 'dart',
  };

  return extensions[language] || 'txt';
}
